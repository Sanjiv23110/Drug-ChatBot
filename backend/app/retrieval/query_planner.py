"""
LLM Query Planner - Retrieval Strategy Generation

Uses LLM to analyze queries and generate retrieval plans WITHOUT seeing PDF content.
The LLM acts as a PLANNER, not a retriever or answer generator.

CRITICAL CONSTRAINTS:
- LLM never sees PDF text
- LLM never generates answers
- LLM never ranks evidence
- LLM only outputs structured retrieval instructions
"""
import os
import json
import logging
from dataclasses import dataclass, asdict
from typing import List, Optional, Literal
from openai import AzureOpenAI

logger = logging.getLogger(__name__)


@dataclass
class RetrievalPlan:
    """
    Structured retrieval plan generated by LLM.
    
    Defines search strategy without accessing source documents.
    """
    # Target drug
    drug: str
    
    # Query classification
    query_mode: Literal['SECTION', 'ATTRIBUTE', 'MULTI_SECTION', 'GENERIC', 'GLOBAL']
    
    # Specific targets (if applicable)
    attribute: Optional[str] = None  # e.g., 'half_life', 'bioavailability'
    candidate_sections: Optional[List[str]] = None  # e.g., ['pharmacology', 'dosage']
    
    # Lexical expansion for recall
    search_phrases: Optional[List[str]] = None  # Synonyms, abbreviations, lay terms
    
    # Extraction granularity
    extraction_level: Literal['sentence', 'block'] = 'sentence'
    
    # Confidence in plan
    confidence: float = 0.8
    
    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return asdict(self)
    
    def to_json(self) -> str:
        """Convert to JSON string."""
        return json.dumps(self.to_dict(), indent=2)


class QueryPlanner:
    """
    LLM-based query analysis for retrieval optimization.
    
    The LLM acts as a retrieval strategist:
    1. Identifies target drug
    2. Classifies query type
    3. Expands search terms with medical synonyms
    4. Suggests candidate sections
    5. Determines extraction granularity
    
    It does NOT:
    - See PDF content
    - Generate answers
    - Rank evidence
    - Make final decisions
    """
    
    # Comprehensive prompt template
    PLANNER_PROMPT = """You are a medical information retrieval strategist for a drug monograph QA system.

Your ONLY job is to analyze a user's query and output a structured retrieval plan in JSON format.

You do NOT:
- See drug monograph content
- Answer questions
- Retrieve information
- Generate responses

You ONLY output a JSON plan that tells the retrieval system HOW to search.

# Output Format (STRICT JSON)

{
  "drug": "lowercase drug name (generic or brand)",
  "query_mode": "SECTION | ATTRIBUTE | MULTI_SECTION | GENERIC | GLOBAL",
  "attribute": "specific medical attribute or null",
  "candidate_sections": ["list of likely section names"],
  "search_phrases": ["lexically expanded search terms"],
  "extraction_level": "sentence | block",
  "confidence": 0.0-1.0
}

# Query Modes

- **SECTION**: Asks about a specific section (e.g., "What are the contraindications?")
- **ATTRIBUTE**: Asks about a specific medical attribute (e.g., "What is the half-life?")
- **MULTI_SECTION**: Requires information from multiple sections (e.g., "Why is dose adjusted in elderly?")
- **GENERIC**: Broad overview question (e.g., "What is AXID?")
- **GLOBAL**: No clear focus, scan all content

# Known Medical Attributes

If the query asks about a specific pharmacological property, set the attribute field:

- half_life
- bioavailability
- tmax (time to max concentration)
- cmax (maximum concentration)
- metabolism
- elimination
- clearance
- onset_of_action
- duration_of_action
- mechanism_of_action
- protein_binding
- volume_of_distribution
- pregnancy_category
- lactation_safety
- active_metabolites

# Common Section Names

Standard drug monograph sections (use these as candidates):

- indications (therapeutic uses)
- contraindications (when not to use)
- dosage (how to administer)
- warnings (important safety information)
- precautions (special considerations)
- adverse_reactions (side effects)
- adverse_effects (synonymous with above)
- pharmacology (how it works)
- pharmacokinetics (absorption, distribution, metabolism, excretion)
- pharmacodynamics (drug effects)
- interactions (drug-drug, drug-food)
- drug_interactions
- food_interactions
- overdosage (toxicity information)
- storage (how to store)
- composition (ingredients)
- description (drug overview)
- mechanism_of_action
- clinical_studies
- patient_information
- pregnancy
- pediatric_use
- geriatric_use
- renal_impairment
- hepatic_impairment

# Search Phrase Expansion Strategy

For each query, generate lexically expanded search terms that include:

1. **Medical synonyms**
   - "side effects" → ["side effects", "adverse reactions", "adverse effects", "undesirable effects"]
   - "how it works" → ["mechanism of action", "pharmacodynamics", "mode of action"]

2. **Abbreviations and full forms**
   - "PK" → ["pharmacokinetics", "PK", "ADME"]
   - "t1/2" → ["half-life", "elimination half-life", "t1/2", "terminal half-life"]

3. **Lay terms and technical terms**
   - "how long in body" → ["half-life", "elimination", "duration", "how long stays"]
   - "gets absorbed" → ["bioavailability", "absorption", "systemic availability"]

4. **Related concepts**
   - "kidney problems" → ["renal impairment", "renal failure", "kidney disease", "CrCl"]
   - "liver issues" → ["hepatic impairment", "liver dysfunction", "cirrhosis"]

# Extraction Level

- **sentence**: Query needs a single precise fact (e.g., "What is the half-life?")
- **block**: Query needs a complete explanation or list (e.g., "What are all the contraindications?")

# Examples

## Example 1: Specific Attribute
User Query: "How long does AXID stay in the body?"

Output:
{
  "drug": "axid",
  "query_mode": "ATTRIBUTE",
  "attribute": "half_life",
  "candidate_sections": ["pharmacology", "pharmacokinetics"],
  "search_phrases": [
    "half-life",
    "elimination half-life",
    "terminal half-life",
    "t1/2",
    "plasma elimination",
    "how long stays in body",
    "duration in system"
  ],
  "extraction_level": "sentence",
  "confidence": 0.95
}

## Example 2: Multi-Section Reasoning
User Query: "Why does renal impairment require AXID dose adjustment?"

Output:
{
  "drug": "axid",
  "query_mode": "MULTI_SECTION",
  "attribute": null,
  "candidate_sections": ["pharmacokinetics", "dosage", "warnings", "renal_impairment"],
  "search_phrases": [
    "renal impairment",
    "kidney disease",
    "renal failure",
    "CrCl",
    "creatinine clearance",
    "dose adjustment",
    "dosage modification",
    "elimination",
    "renal clearance"
  ],
  "extraction_level": "block",
  "confidence": 0.9
}

## Example 3: Section Query
User Query: "What are the contraindications of nizatidine?"

Output:
{
  "drug": "nizatidine",
  "query_mode": "SECTION",
  "attribute": null,
  "candidate_sections": ["contraindications"],
  "search_phrases": [
    "contraindications",
    "contraindicated",
    "should not use",
    "do not use",
    "when not to use",
    "warnings against use"
  ],
  "extraction_level": "block",
  "confidence": 1.0
}

## Example 4: Generic Overview
User Query: "Tell me about AXID"

Output:
{
  "drug": "axid",
  "query_mode": "GENERIC",
  "attribute": null,
  "candidate_sections": ["description", "indications", "pharmacology"],
  "search_phrases": [
    "AXID",
    "nizatidine",
    "what is",
    "overview",
    "description",
    "therapeutic class",
    "drug class"
  ],
  "extraction_level": "block",
  "confidence": 0.7
}

# Now Analyze This Query

User Query: {query}

Output ONLY valid JSON using the format above. No explanations, no additional text."""

    def __init__(self):
        """Initialize LLM planner with Azure OpenAI."""
        self.client = AzureOpenAI(
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION", "2024-12-01-preview")
        )
        self.model = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT", "gpt-4o")
        logger.info(f"QueryPlanner initialized with model: {self.model}")
    
    async def plan(self, query: str) -> RetrievalPlan:
        """
        Generate retrieval plan for a query.
        
        Args:
            query: User's natural language question
            
        Returns:
            RetrievalPlan with structured search strategy
        """
        try:
            logger.info(f"Generating retrieval plan for query: {query[:100]}...")
            
            # Call LLM with structured output
            response = self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {
                        "role": "user",
                        "content": self.PLANNER_PROMPT.format(query=query)
                    }
                ],
                temperature=0,  # Deterministic planning
                response_format={"type": "json_object"}  # Force JSON output
            )
            
            # Parse JSON response
            plan_json = json.loads(response.choices[0].message.content)
            
            # Validate and create RetrievalPlan
            plan = RetrievalPlan(
                drug=plan_json.get('drug', 'unknown').lower(),
                query_mode=plan_json.get('query_mode', 'GLOBAL'),
                attribute=plan_json.get('attribute'),
                candidate_sections=plan_json.get('candidate_sections', []),
                search_phrases=plan_json.get('search_phrases', [query]),
                extraction_level=plan_json.get('extraction_level', 'sentence'),
                confidence=plan_json.get('confidence', 0.8)
            )
            
            logger.info(
                f"Generated plan: mode={plan.query_mode}, "
                f"drug={plan.drug}, "
                f"sections={plan.candidate_sections}, "
                f"phrases={len(plan.search_phrases)}"
            )
            
            return plan
            
        except json.JSONDecodeError as e:
            logger.error(f"LLM returned invalid JSON: {e}")
            return self._fallback_plan(query)
        
        except Exception as e:
            logger.error(f"Query planning failed: {e}", exc_info=True)
            return self._fallback_plan(query)
    
    def _fallback_plan(self, query: str) -> RetrievalPlan:
        """
        Generate basic fallback plan when LLM fails.
        
        Uses simple heuristics to create a minimal plan.
        """
        logger.warning("Using fallback retrieval plan")
        
        # Extract potential drug name (first capitalized word)
        words = query.split()
        drug = "unknown"
        for word in words:
            if len(word) > 3 and word[0].isupper():
                drug = word.lower()
                break
        
        return RetrievalPlan(
            drug=drug,
            query_mode="GLOBAL",
            search_phrases=[query],
            extraction_level="block",
            confidence=0.5
        )


# Testing and validation
if __name__ == "__main__":
    import asyncio
    
    async def test_planner():
        """Test query planner with example queries."""
        planner = QueryPlanner()
        
        test_queries = [
            "What is the half-life of AXID?",
            "What are the contraindications of nizatidine?",
            "Why is dose adjustment needed in renal impairment?",
            "Tell me about AXID",
            "Can pregnant women take this drug?",
        ]
        
        for query in test_queries:
            print(f"\n{'='*80}")
            print(f"Query: {query}")
            print(f"{'='*80}")
            
            plan = await planner.plan(query)
            print(plan.to_json())
    
    asyncio.run(test_planner())
