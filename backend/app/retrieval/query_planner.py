"""
LLM Query Planner - Retrieval Strategy Generation

Uses LLM to analyze queries and generate retrieval plans WITHOUT seeing PDF content.
The LLM acts as a PLANNER, not a retriever or answer generator.

CRITICAL CONSTRAINTS:
- LLM never sees PDF text
- LLM never generates answers
- LLM never ranks evidence
- LLM only outputs structured retrieval instructions
"""

import os
import json
import logging
from dataclasses import dataclass, asdict
from typing import List, Optional, Literal
from openai import AsyncAzureOpenAI

logger = logging.getLogger(__name__)


# ---------------------------
# Data Model
# ---------------------------

@dataclass
class RetrievalPlan:
    """
    Structured retrieval plan generated by LLM.
    """
    drug: str
    query_mode: Literal['SECTION', 'ATTRIBUTE', 'MULTI_SECTION', 'GENERIC', 'GLOBAL']
    attribute: Optional[str] = None
    candidate_sections: Optional[List[str]] = None
    search_phrases: Optional[List[str]] = None
    extraction_level: Literal['sentence', 'block'] = 'sentence'
    confidence: float = 0.8

    def to_dict(self) -> dict:
        return asdict(self)

    def to_json(self) -> str:
        return json.dumps(self.to_dict(), indent=2)


# ---------------------------
# Query Planner
# ---------------------------

class QueryPlanner:
    """
    LLM-based query analysis for retrieval optimization.
    """

    PLANNER_PROMPT = """
You are a medical information retrieval strategist for a drug monograph QA system.

Your ONLY job is to analyze a user's query and output a structured retrieval plan in JSON format.

You do NOT:
- See drug monograph content
- Answer questions
- Retrieve information
- Generate responses

You ONLY output a JSON plan that tells the retrieval system HOW to search.

# Output Format (STRICT JSON)

{{
  "drug": "lowercase drug name (generic or brand)",
  "query_mode": "SECTION | ATTRIBUTE | MULTI_SECTION | GENERIC | GLOBAL",
  "attribute": "specific medical attribute or null",
  "candidate_sections": ["list of likely section names"],
  "search_phrases": ["lexically expanded search terms"],
  "extraction_level": "sentence | block",
  "confidence": 0.0
}}

# Query Modes
- SECTION
- ATTRIBUTE
- MULTI_SECTION
- GENERIC
- GLOBAL

# Known Medical Attributes
- half_life
- bioavailability
- metabolism
- elimination
- clearance
- mechanism_of_action
- pregnancy_category
- pediatric_use
- geriatric_use
- renal_impairment
- hepatic_impairment

# Example

User Query: "How long does AXID stay in the body?"

Output:
{{
  "drug": "axid",
  "query_mode": "ATTRIBUTE",
  "attribute": "half_life",
  "candidate_sections": ["pharmacokinetics"],
  "search_phrases": ["half-life", "elimination half-life"],
  "extraction_level": "sentence",
  "confidence": 0.95
}}

# Now Analyze This Query

User Query: {query}

Output ONLY valid JSON. No explanations.
"""


    def __init__(self):
        self.client = AsyncAzureOpenAI(
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT"),
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION", "2024-12-01-preview")
        )
        self.model = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT", "gpt-4o")
        logger.info(f"QueryPlanner initialized with model: {self.model}")

    # ---------------------------
    # HARD SANITIZER (CRITICAL FIX)
    # ---------------------------

    def _sanitize_plan_json(self, plan_json: dict, query: str) -> dict:
        """
        Enforce hard invariants on planner output.
        Retrieval MUST NEVER receive malformed data.
        """
        sanitized = {}

        # drug
        drug = plan_json.get("drug")
        if not isinstance(drug, str) or not drug.strip():
            drug = "unknown"
        sanitized["drug"] = drug.lower()

        # query_mode
        valid_modes = {"SECTION", "ATTRIBUTE", "MULTI_SECTION", "GENERIC", "GLOBAL"}
        mode = plan_json.get("query_mode")
        if mode not in valid_modes:
            mode = "GLOBAL"
        sanitized["query_mode"] = mode

        # attribute
        attr = plan_json.get("attribute")
        sanitized["attribute"] = attr if isinstance(attr, str) else None

        # candidate_sections
        sections = plan_json.get("candidate_sections")
        sanitized["candidate_sections"] = sections if isinstance(sections, list) else []

        # search_phrases
        phrases = plan_json.get("search_phrases")
        sanitized["search_phrases"] = phrases if isinstance(phrases, list) and phrases else [query]

        # extraction_level
        extraction = plan_json.get("extraction_level")
        sanitized["extraction_level"] = extraction if extraction in {"sentence", "block"} else "block"

        # confidence
        conf = plan_json.get("confidence")
        sanitized["confidence"] = float(conf) if isinstance(conf, (int, float)) else 0.5

        return sanitized

    # ---------------------------
    # MAIN PLANNER
    # ---------------------------

    async def plan(self, query: str) -> RetrievalPlan:
        try:
            logger.info(f"Planning query: {query}")

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": self.PLANNER_PROMPT.format(query=query)}],
                temperature=0,
                response_format={"type": "json_object"}
            )

            raw_plan = json.loads(response.choices[0].message.content)
            plan_json = self._sanitize_plan_json(raw_plan, query)

            plan = RetrievalPlan(
                drug=plan_json["drug"],
                query_mode=plan_json["query_mode"],
                attribute=plan_json["attribute"],
                candidate_sections=plan_json["candidate_sections"],
                search_phrases=plan_json["search_phrases"],
                extraction_level=plan_json["extraction_level"],
                confidence=plan_json["confidence"]
            )

            logger.info(
                f"Planner OK | mode={plan.query_mode} | drug={plan.drug} | phrases={len(plan.search_phrases)}"
            )
            return plan

        except Exception as e:
            logger.error(f"Query planning failed, using fallback: {e}", exc_info=True)
            return self._fallback_plan(query)

    # ---------------------------
    # FALLBACK (LAST RESORT)
    # ---------------------------

    def _fallback_plan(self, query: str) -> RetrievalPlan:
        logger.warning("Using fallback retrieval plan")

        drug = "unknown"
        for word in query.split():
            if len(word) > 3 and word[0].isupper():
                drug = word.lower()
                break

        return RetrievalPlan(
            drug=drug,
            query_mode="GLOBAL",
            search_phrases=[query],
            extraction_level="block",
            confidence=0.3
        )


# ---------------------------
# Local Test
# ---------------------------

if __name__ == "__main__":
    import asyncio
    from dotenv import load_dotenv
    load_dotenv()

    async def test():
        planner = QueryPlanner()
        q = "What dosage forms and strengths are available for AXID?"
        plan = await planner.plan(q)
        print(plan.to_json())

    asyncio.run(test())
